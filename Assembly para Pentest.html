<!DOCTYPE html>
<html lang="pt-BR">
<head>
	<meta charset="utf-8">
	<link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap" rel="stylesheet">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>xispe</title>
	<link rel="icon" type="image/x-icon" href="Imagens/Icone.png">
	<style>
		body { 
			background-color:#090B0B;
			height: auto;
		}

		h1 { 
			color: #E5EBEA;
			font-family: ubuntu;
			font-size: 48px;
		}
		
		h2 { 
			color: #E5EBEA;
			font-family: ubuntu;
			font-size: 32px; }

		h3 { 
			color: #E5EBEA;
			font-family: ubuntu;
			font-size: 28px; }
		
		p { 
			color: #E5EBEA;
			font-family: ubuntu;
			font-size: 24px;
		}

		li {
			color: #E5EBEA;
			font-family: ubuntu;
			font-size: 24px;
		}

		a {
			color: #8A8DA2;
			font-family: ubuntu;
			font-size: 24px;
			display: inline-block;
			padding: inherit;
			word-wrap: break-word;
		}

		u {
			color: #8A8DA2;
			font-family: ubuntu;
		}

		img {
			width: 80%;
			align-self: center;
		}

		footer {
			display: flex;
			flex-direction: column;
			text-align: center;
			padding: 20px;
		}

#		code {
			font-size: 18px;
			padding: inherit;
			display: inline-block;
			word-wrap: break-word;
		}

		.cabecalho{
			width: 60;
			max-width: 500px;
			min-width: 300px;
			padding: 20px;
		}

		.layout {
			display: flex;
			flex-direction: column;
			padding-inline: 10%;
		}

	</style>
</head>
<body>
	<div align="center"><a href="https://xispe.github.io"><img class="cabecalho" src="Imagens/cabeçalho.png" title="Pagina Inicial"></a></div>

	<div class="layout">
		<h1>Assembly para Pentest</h1>

		<h2>Introdução</h2>
		<p>Esse artigo é introdutório para a linguagem Assembly, ele não tem interesse em aprofundar-se, já que essa linguagem no contexto de Pentests é usada apenas como uma ferramenta. Além do básico, também terá as principais ferramentas para manipular essa linguagem.</p>
		<h2>O que é Assembly</h2>
		<p>Para entender o que é essa linguagem de programação, é primeiro necessário entendermos um pouco do funcionamento dos computadores, especificamente a parte considerada o "cérebro" do computador, a CPU.</p>
		<h3>Central Processing Unit - CPU</h3>
		<p>Também conhecida como processador, é a parte responsável por fazer diversas operações lógicas, aritméticas, processamento de dados e executar o <strong>código de máquina</strong> de um programa de computador (que é a parte que mais nos interessa).</p>
		<p>O código de máquina é um conjunto de instruções definidas por sua arquitetura, denominada como ISA (Instruction Set Archtecture), e elas são comumente representadas em hexadecimal como mostra o exemplo:</p>
		<pre><code>
<span class="hljs-number">31</span> <span class="hljs-number">c0</span>
b8 <span class="hljs-number">28</span> <span class="hljs-number">23</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-number">50</span>
bb <span class="hljs-number">10</span> <span class="hljs-number">90</span> <span class="hljs-number">12</span> <span class="hljs-number">76</span>
ff d3
		</code></pre>
		<h3>Montagem ou Assembly</h3>
		<p>Do ponto de vista humano, entender instruções em código de máquina é muito difícil. Por isso os manuais da ISA, para facilitar a criação, simplificam o entendimento das instruções se referindo à elas em formato de texto. Esse formato é conhecido como notação mnemônico.</p>
		<pre><code>
<span class="hljs-number">31</span> c0              XOR EAX, EAX  
b8 <span class="hljs-number">28</span> <span class="hljs-number">23</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>     MOV EAX, <span class="hljs-number">0X2328</span>
<span class="hljs-number">50</span>                 PUSH EAX
bb <span class="hljs-number">10</span> <span class="hljs-number">90</span> <span class="hljs-number">12</span> <span class="hljs-number">76</span>     MOV EBX, <span class="hljs-number">0X76129010</span>
ff d3              CALL EBX
		</code></pre>
		<p>Sendo essa notação usada para <strong>montar</strong> o código de máquina, o que a gente conhece atualmente como "linguagem Assembly" (Assembly remete a assembler que se traduz em montagem). Na verdade não existe uma única linguagem mas sim cada ISA tem uma linguagem Assembly diferente.</p>
		<p>Anteriormente, os programadores escreviam seus códigos usando a notação em texto e depois manualmente convertiam para código de máquina. Porém, atualmente existem softwares que fazem esse processo automaticamente, chamados de <strong>assemblers</strong>.</p>
		<h2>Diferentes Arquiteturas</h2>
		<p>Existem algumas arquiteturas diferentes, e entre elas existem diferenças significativas. As arquiteturas mais conhecidas são a x86 e x86-64. Dentre as diferenças existentes destaca-se as seguintes:</p>
		<h3>Tamanho da capacidade</h3>
		<p>As arquiteturas se diferem no tamanho da capacidade padrão de dados. Como exemplo, x86 é compatível com 32 bits e o x86-64 com 64 bits. E ainda, sistemas 64 bits permitem operar com diferentes tamanhos de dados e acessar quantidades maiores de memória.</p>
		<h3>Registros de propósito geral</h3>
		<p>O número de <strong>registradores</strong> (pequenas unidades de armazenamento rápido) variam. Sendo que, arquiteturas x86 têm menos registradores em comparação com x86-64.</p>
		<h2>Stack</h2>
		<p>A stack ou pilha em português, é um espaço continuo de memória que os programas usam para manipular dados. E ainda, é utilizada para a "comunicação" durante chamadas e retornos de funções.</p>
		<p>A stack ainda tem o comportamento LIFO (Last In First Out, em português Ultimo que entra é o primeiro a sair), como o nome diz replicando a característica de uma pilha. Logo, vale citar que quando inserindo informações na stack é necessário levar em consideração essa condição e inverter a ordem das informações.</p>
		<p>E existe ainda alguns endereços fundamentais como:</p>
		<ul>
		<li>ESP: que indica para o topo da Stack.</li>
		<li>Buffer: Usado para armazenar informações caso o programa necessite.</li>
		<li>EBP: Que indica a base da Stack,</li>
		<li>EPI: Que indica o próximo endereço para execução.</li>
		</ul>
		<h2>Sintaxe Básica</h2>
		<ul>
		<li>global: torna uma variável ou função acessível a outros arquivos do código.
		<ul>
		<li>Normalmente usado no começo do código para definir o bloco principal.</li>
		</ul></li>
		<li>section: usado para definir e organizar diferentes partes da memória onde o código e os dados da memória serão armazenados.
		<ul>
		<li>.text: Armazerna o código executavel.</li>
		<li>.data: Armazena os dados inicializados, em outras palavras, as variaveis definidas previamente.
		<ul>
		<li>Exemplo de uso: nome db "valor da variavel", 0 (ou 0xa que equivale \n)</li>
		</ul></li>
		</ul></li>
		<li>extern: usado para declarar que uma função ou variável esta definida em outro arquivo. Permite referenciar funções externas.</li>
		<li>Comentários: pode ser feitos usando ``;</li>
		<li>Números: podem ser escritos em base decimal, hexadecimal, octal e binário. Exemplos:
		<ul>
		<li>Binário: 0b001</li>
		<li>Decimal: 12</li>
		<li>Hexadecimal: 0x0a ou 41424344h</li>
		<li>Octal: 0o10</li>
		</ul></li>
		<li>Pseudo-intruções: são instruções para o Assembler, como o <code>db</code> que serve pra já associar valores no correspondente local do arquivo binário de saída (Define valor à um endereço).</li>
		<li>Rótulo: ou label em inglês, é basicamente um bloco de código que pode ser organizado hierarquicamente entre outros rótulos. Para definir um rótulo local basta adicionar um <code>.</code> antes do nome.</li>
		<li>Não há diferença entre caixa-baixa ou alta para Assembly</li>
		</ul>
		<h3>Sintaxe Intel x AT&amp;T</h3>
		<p>Existem duas sintaxes diferentes para programar em Assembly (Intel ou AT&amp;T).</p>
		<p>A sintaxe da Intel é no seguinte formato: MOV EAX, 3</p>
		<ul>
		<li>Direção destino &lt;-- origem.</li>
		</ul>
		<p>Já a sintaxe AT&amp;T:
		MOV $0X3, %EAX</p>
		<ul>
		<li>Direção origem --&gt; destino.</li>
		<li>% para registradores.</li>
		<li>$ para números.</li>
		</ul>
		<p>O artigo será escrito usando a sintaxe Intel.</p>
		<h3>Instruções</h3>
		<table>
		<thead>
		<tr><th>Instrução</th><th>Função</th></tr>
		</thead>
		<tbody>
		<tr><td>MOV</td><td>Move</td></tr>
		<tr><td>ADD</td><td>Adiciona</td></tr>
		<tr><td>SUB</td><td>Subtrai</td></tr>
		<tr><td>INC</td><td>Incrementa</td></tr>
		<tr><td>DEC</td><td>Descrementa</td></tr>
		<tr><td>CALL</td><td>Chama</td></tr>
		<tr><td>JMP</td><td>Salta</td></tr>
		<tr><td>JNE</td><td>Salta se não for igual</td></tr>
		<tr><td>CMP</td><td>Compara</td></tr>
		<tr><td>PUSH</td><td>Coloca na Stack (Topo)</td></tr>
		<tr><td>POP</td><td>Retira da Stack (Topo)</td></tr>
		<tr><td>NOP</td><td>No Operation (\x90)</td></tr>
		<tr><td>INT3</td><td>Interrupção (Breakpoint)</td></tr>
		<tr><td>XOR</td><td>Instruções Lógicas</td></tr>
		</tbody>
		</table>
		<h3>Exemplos de uso</h3>
	<pre><code>
<span class="hljs-keyword">MOV</span> <span class="hljs-built_in">EAX</span>, <span class="hljs-number">3</span> # Coloca o valor <span class="hljs-number">3</span> no endereço de memória <span class="hljs-built_in">EAX</span>
<span class="hljs-keyword">MOV</span> <span class="hljs-built_in">EAX</span>, [<span class="hljs-built_in">ESP</span>] # Coloca o conteú<span class="hljs-built_in">do</span> <span class="hljs-built_in">do</span> topo da Stack para <span class="hljs-built_in">EAX</span>
<span class="hljs-keyword">XOR</span> <span class="hljs-built_in">EAX</span>, <span class="hljs-built_in">EAX</span> # Zera o valor em <span class="hljs-built_in">EAX</span>
<span class="hljs-keyword">NOP</span> # Não faz nada
<span class="hljs-keyword">PUSH</span> <span class="hljs-number">0x3</span> # Envia o valor <span class="hljs-number">3</span> em Hex para o topo da Stack
<span class="hljs-keyword">POP</span> <span class="hljs-built_in">EAX</span> # Coloca o valor <span class="hljs-built_in">do</span> topo da Stack para <span class="hljs-built_in">EAX</span>
	</code></pre>
		<h2>Compilação</h2>
		<p>Para transformar o código em Assembly para um arquivo executável é necessário fazer dois procedimentos, sendo eles o assembler e "linkagem"</p>
		<ul>
		<li>Assembler: para esse processo é indicado usar o nasm, que é considerado por muitos o melhor. Nesse momento o arquivo que esta com as instruções é transformado em código de máquina em um formato <code>.obj</code> ou <code>.o</code>.</li>
		<li>Linkagem: Nesse processo pode ser usado o golink (no Windows), ou o ld (para linux). Esse processo junta funções externas citadas em seu código e as associam de forma correta. O linker gerará o arquivo executável.</li>
		</ul>
		<h2>Desenvolvendo para Windows</h2>
		<p>Quando desenvolvendo em Assembly para Windows é necessário seguir alguns processos. Primeiramente, é fundamental ter em mãos o site da Microsoft onde terá todas as funções que serão referenciadas e os arquivos que devem ser linkados
		<a href="https://learn.microsoft.com/en-us/windows/win32/api/">https://learn.microsoft.com/en-us/windows/win32/api/</a></p>
		<p>Como exemplo temos o seguinte código usado para criar uma caixa exibindo uma mensagem:</p>
		<pre><code class="language-Asm">
<span class="hljs-meta">extern</span> _MessageBoxA <span class="hljs-comment">; declarando a funcao externa que sera usada</span>

<span class="hljs-meta">global</span> main

<span class="hljs-meta">section</span> .data <span class="hljs-comment">; espaco dedicado a declarar variaveis</span>
    msg <span class="hljs-built_in">db</span> <span class="hljs-string">"Mensagem teste"</span>,<span class="hljs-number">0</span> <span class="hljs-comment">; db stands for declarative byte</span>
    titulo <span class="hljs-built_in">db</span> <span class="hljs-string">"Titulo da caixa"</span>,<span class="hljs-number">0</span> <span class="hljs-comment">; ,0 serve como uma quebra de linha na secao de declaracao de variaveis</span>
		    
<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">main:</span>
    <span class="hljs-keyword">PUSH</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">PUSH</span> titulo
    <span class="hljs-keyword">PUSH</span> msg
    <span class="hljs-keyword">PUSH</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">CALL</span> _MessageBoxA
		</code></pre>
<p>Onde temos a parte superior onde definimos que será usada uma função externa <code>_MessageBoxA</code> usando o comando <code>extern</code>, e logo após temos a definições das variáveis que serão usadas.</p>
<p>E acompanhando a sintaxe provida pelo site temos que está em C++:</p>
<pre><code class="language-C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageBox</span><span class="hljs-params">( 
    [in, optional] HWND hWnd, # Um valor handle que recebe o valor <span class="hljs-number">0</span>
    [in, optional] LPCTSTR lpText, # O valor que estará no texto
    [in, optional] LPCTSTR lpCaption, # O título da caixa
    [in] UINT uType # O tipo da caixa (Olhar o site para ver cada exemplo)
)</span></span>;
		</code></pre>
		<p>E considerando que na stack todos os comandos terão que ser enviados ao contrário temos a ordem:</p>
		<pre><code class="language-Asm">
<span class="hljs-symbol">main:</span>
	<span class="hljs-keyword">PUSH</span> <span class="hljs-number">0</span> <span class="hljs-meta"># Valor do tipo</span>
	<span class="hljs-keyword">PUSH</span> titulo <span class="hljs-meta"># Texto do título</span>
	<span class="hljs-keyword">PUSH</span> msg <span class="hljs-meta"># Texto da caixa</span>
	<span class="hljs-keyword">PUSH</span> <span class="hljs-number">0</span> <span class="hljs-meta"># Valor do handle</span>
	<span class="hljs-keyword">CALL</span> _MessageBoxA
		</code></pre>
		<p>Por fim chamando o espaço da memória onde está a função da caixa de mensagem.</p>
		<h2>Compilando no Windows</h2>
		<p>Quando estamos compilando o código no Windows usaremos os nasm e o golink da seguinte forma:
		<code>nasm -f win32 projeto.asm</code>golink /entry bloco principal de codigo projeto.obj arquivo a ser linkado ao código</p>
		<p>Seguindo o exemplo mostrado acima usaremos os seguintes comandos e seguindo as necessidades do site da Microsoft:</p>
		<pre><code>
nasm -f win32 caixa<span class="hljs-selector-class">.asm</span>
golink /entry main caixa<span class="hljs-selector-class">.obj</span> User32<span class="hljs-selector-class">.dll</span>
		</code></pre>
		<p>Assim teremos o arquivo <code>.exe</code> funcional.</p>
		<h2>Desenvolvendo para Linux</h2>
		<p>Para desenvolver em linux o processo é bem diferente se comparado com o Windows. Primeiramente é fundamental conhecer a ferramenta man, que é um manual digital onde podemos ver sobre as funções e ferramentas do sistema. Essa ferramenta é fundamental pois através dela teremos acesso ao manual ISA do nosso sistema.</p>
		<p>E no linux nos usaremos as chamadas <code>syscall</code> para trazer as funcionalidades ao nosso código. Então para começar devemos fazer o seguinte comando: <code>man syscall</code></p>
		<p>E apesar de todo o manual ser muito útil, o que mais nos interessa são as tabelas <code>Architecture calling conventions</code>, onde veremos qual é a instrução que fará a chamada da função do sistema, e a tabela usada para passar aos argumentos. Para praticidade irei colocar aqui somente as que nos interessa, porém vale sempre usar o man como referência.</p>
		<pre><code> 
Arch/ABI    Instruction           System  <span class="hljs-keyword">Ret</span>  <span class="hljs-keyword">Ret</span>  Error    Notes
───────────────────────────────────────────────────────────────────
i386        <span class="hljs-keyword">int</span> <span class="hljs-number">$0</span>x80             <span class="hljs-built_in">eax</span>     <span class="hljs-built_in">eax</span>  <span class="hljs-built_in">edx</span>  -
x86-<span class="hljs-number">64</span>      <span class="hljs-keyword">syscall</span>               <span class="hljs-built_in">rax</span>     <span class="hljs-built_in">rax</span>  <span class="hljs-built_in">rdx</span>  -        <span class="hljs-number">5</span>
───────────────────────────────────────────────────────────────────

Arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes
──────────────────────────────────────────────────────────────
i386          <span class="hljs-built_in">ebx</span>   <span class="hljs-built_in">ecx</span>   <span class="hljs-built_in">edx</span>   <span class="hljs-built_in">esi</span>   <span class="hljs-built_in">edi</span>   <span class="hljs-built_in">ebp</span>   -
x86-<span class="hljs-number">64</span>        <span class="hljs-built_in">rdi</span>   <span class="hljs-built_in">rsi</span>   <span class="hljs-built_in">rdx</span>   <span class="hljs-built_in">r10</span>   <span class="hljs-built_in">r8</span>    <span class="hljs-built_in">r9</span>    -
──────────────────────────────────────────────────────────────
		</code></pre>
		<p>Primeiro iremos usar a arquitetura x86 ou como está escrito i386. Teremos que abrir o arquivo que tem o código que identifica cada syscall, que fica na pasta <code>asm</code> em algum lugar do endereço <code>/usr/include/</code>, no caso atual usaremos o arquivo <code>unistd_32.h</code>.  Usaremos os seguinte código que mostra o famoso "Hello World" como referência:</p>
		<pre><code class="language-Asm">
<span class="hljs-meta">global</span> main
<span class="hljs-meta">section</span> .data
<span class="hljs-symbol">    teste:</span> <span class="hljs-built_in">db</span> <span class="hljs-string">'Hello Word'</span>, <span class="hljs-number">0xa</span>
<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">main:</span>
    <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">EAX</span>, <span class="hljs-number">4</span>
    <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">EBX</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">ECX</span>, teste
    <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">EDX</span>, <span class="hljs-number">11</span>
    <span class="hljs-keyword">INT</span> <span class="hljs-number">0X80</span>
    
    <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">EAX</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">EBX</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">INT</span> <span class="hljs-number">0X80</span>
		</code></pre>
		<p>Nesse código temos 2 funções sendo usadas, sendo a primeira a função <code>write</code> que, de acordo com o arquivo citado acima, possui o código 4 que foi colocado no registrador EAX conforme citado na tabela. E olhando o manual dessa função por meio do comando <code>man 2 write</code>, vemos que ela recebe 3 argumentos, sendo eles o FD (File Descriptor) que recebe o valor 1 para somente mostrar na tela, o texto que será usado e o tamanho do texto. Logo após temos a função <code>exit</code> usada para fechar o código sem causar nenhum erro.</p>
		<p>Agora para a arquitetura x86-64, perceberemos que não existe muitas diferenças. Primeiramente abriremos o arquivo <code>unistd_64.h</code> e perceberemos que as funções possuem números diferentes. E ainda, levando em consideração que a syscall e os registradores são diferentes, teremos o código da seguinte forma:</p>
		<pre><code class="language-Asm">
global main
section .<span class="hljs-keyword">data</span>
    texto: db <span class="hljs-string">'Hello World'</span>, <span class="hljs-number">0xa</span>
section .<span class="hljs-keyword">data</span>
main:
    MOV RAX, <span class="hljs-number">1</span> ; Definindo a <span class="hljs-function"><span class="hljs-keyword">fun</span>ção write</span>
    MOV RD1, <span class="hljs-number">1</span> ; Configurando como STDOUT
    MOV RSI, texto ; Texto
    MOV RDX, <span class="hljs-number">11</span> ; Tamanho <span class="hljs-keyword">do</span> texto
    SYSCALL ; Chamada para executar a <span class="hljs-function"><span class="hljs-keyword">fun</span>ção write</span>

    MOV RAX, <span class="hljs-number">60</span> ; Definindo a <span class="hljs-function"><span class="hljs-keyword">fun</span>ção exit</span>
    MOV RDI, <span class="hljs-number">0</span> ; Código para sem erros
    SYSCALL ; Chamada da <span class="hljs-function"><span class="hljs-keyword">fun</span>ção exit</span>
		</code></pre>
		<h2>Compilando no Linux</h2>
		<p>Para compilar o código no linux iremos usar o nasm e o ld da seguinte forma:</p>
		<pre><code>
nasm -f elf32 arquivo.<span class="hljs-keyword">asm</span> <span class="hljs-comment"># Para a arquitetura x86</span>
nasm -f elf64 arquivo.<span class="hljs-keyword">asm</span> <span class="hljs-comment"># Para a arquitetura x86-64</span>
		</code></pre>
		<pre><code>
<span class="hljs-keyword">ld</span> --entry -m elf_i386 arquivo.o -o arquivo <span class="hljs-meta"># Para arquitetura x86</span>
<span class="hljs-keyword">ld</span> --entry -m elf_x86_64 arquivo.o -o arquivo <span class="hljs-meta"># Para arquitetura x86-64</span>
		</code></pre>
		<h2>Debuggers</h2>
		<p>Debuggers são ferramentas utilizadas para fazer analises nos softwares após sua compilação. Eles podem ser usado tanto para fazer uma engenharia reversa, quanto para explorar falhas como Buffer Overflow dentre outras funções. Dentre as opções disponíveis recomendo o Immunity Debugger para o Windows, e o gdb para o Linux.</p>
		<h2>Referências</h2>
		<p><a href="https://mentebinaria.gitbook.io/assembly">https://mentebinaria.gitbook.io/assembly</a></p>
		<p><a href="https://eximia.co/entendendo-a-stack-em-sua-forma-mais-primitiva-em-assembly/">https://eximia.co/entendendo-a-stack-em-sua-forma-mais-primitiva-em-assembly/</a></p>

	<footer>
		<u>DD/MM/AAAA</u>
		<u>xispe01@proton.me</u>
	</footer>

</body>
</html>